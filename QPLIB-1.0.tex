%- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
%- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
%  QPLIB-1.0.tex
%- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
%- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

%- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
%- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\section{Introduction}\label{sec:intro}

Quadratic Programming (QP) problems, where either the objective function \cite{wiki:qp}, or the constraints \cite{wiki:qcqp}, or both contain (at most) expressions in the variables of degree $2$, include a surprisingly diverse set of rather different instances. This is not surprising, given the vast scope of practical applications of these problems, and of solution methods designed to solve them \cite{GoulToin00a}. According to the fine details of the formulation, solving a QP may require employing either fundamentally combinatorial techniques, or ideas rooted in nonlinear optimization principles, or a mix of the two. In this sense, QP is likely one of the classes of problems where the collaboration between the communities interested in combinatorial and nonlinear optimization is more necessary, and potentially fruitful.

However, this diversity also implies that QP means very different things to different researchers. This is illustrated by the simple fact that the class of problems that we simply refer to here as ``QP'' is called in different ways, among which Mixed-Integer Quadratically Constrained Quadratic Problems (MI-QCQP). It is perhaps therefore not surprising that, unlike for ``simpler'' problems classes \cite{Koch2011}, so far there has never been a single library containing all different kinds of instances of QP. Several libraries devoted to special cases of QP are indeed available; however, each of them is either focussed on one application (a specific problem that can be modeled as QP), or on QPs with specific structural properties that make them suitable to be solved with some given class of algorithmic approaches. To the best of our knowledge, collecting a set of QP instances that is at the same time not overwhelmingly numerous and significant for the many different interested communities has not been attempted, yet. This work constitutes a first step in this direction.

In this paper we report the steps that have been done to collect a (hopefully) significant library of QP instances, filtering the large set of available (or specifically provided) instances in order to end up with a manageable set that still contains a meaningful sample of all possible QP types. A particularly thorny issue in this process is how to select instances that are ``interesting''. Our choice has been to take this to mean ``challenging for a significant set of solution methods''. Our filtering process has then been in part based on the idea that if a significant fraction of the solvers that can solve a QP instance do so in a ``short'' time, then the instance is not challenging enough to be included in the library. Yet, if very few (maybe one) solvers can solve it very efficiently by exploiting some specific structure, but most other approaches cannot, then the instance can still be deemed ``interesting''. Putting this approach in practice requires a nontrivial number of technical steps and decisions that are detailed in the paper. We hope that our work can provide useful guidelines for other interested researchers.

A consequence of our focus is that this paper is \emph{not} concerned about the different performance of the very diverse QP solvers; we will \emph{not} report any data comparing them. The only reason why solvers are used (and, therefore, described) in this context is to ensure that the instances of the library are nontrivial at least for a significant fraction of the current solution methods; providing guidance about which solver is most suited to some specific class of QPs is entirely outside the scope of our work.

%- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsection{Motivation}\label{subsec:motiv}

\framebox{TASK 2 : write motivation}

Optimization problems with quadratic constraints and/or objective function (QP) have been the subject of a considerable amount of research over the last 60 years. At least some of the rationale for this interest is likely due to the fact that they are the ``least-nonlinear nonlinear problems''. Hence, in particular for the convex case, tools and techniques that have been honed during decades of research for Linear Programming (LP), typically with integrality constraints (MILP), can often be extended to the quadratic case with at least less effort than what would be required for tackling general Non Linear Programming (NLP) problems, without or with integrality constraints (MINLP). This has indeed happened over and over again with different algorithmic techniques, such as Interior Point methods, active-set methods (of which the simplex method is a prototypical example), enumeration methods, cut-generation techniques, reformulation techniques, and many others ({\bf citations?}). Similarly, nonconvex continuous QP are perhaps the ``simplest'' class of problems that require features like spatial enumeration techniques to be solved. Hence, they are both the natural basis for the development of general techniques for nonconvex NLP, and a very specific class so that specialized approaches can be developed \cite{Dur2010,Burer2012}.

On the other hand, (MI)QP is, in some sense, a considerably more expressive class than (MI)LP. Quadratic expressions are found, either naturally or after appropriate reformulations, in very many practical problems (\cite{Kochenberger2014}, {\bf citations?}). In general, any continuous function can be approximated with arbitrary accuracy (over a compact set) by a polynomial of arbitrary degree; in turn, every polynomial can be broken down to a system of quadratic expressions. Hence, (MI)QP is, in some sense, roughly as expressive as the whole of (MI)NLP. Of course this is, in principle, true for (MI)LP as well, but at the cost of much larger and much more complex formulations ({\bf citations?}). Hence, for many applications QP may represent the ``sweet spot'' between the effectiveness, but lower expressive power, of (MI)LP and the higher expressive power, but much higher computational cost, of (MI)NLP.

\ldots

The structure of this paper is the following. In \S~\ref{sec:QPbasic} we review the basic notions about QP. In particular, \S~\ref{subsec:notation} sets out the notation, \S~\ref{sec:classification} proposes a---to the best of our knowledge, new---taxonomy of QP that helps us in discussing the (very) different classes of QPs, \S~\ref{sec:algo} very briefly reviews the solution methods for QP upon which the solvers we have employed are based, and \S~\ref{subsec:solver} describes the solvers. Then, \S~\ref{sec:lib} describes the process used to obtain the library and its results; the software tools that we have used, and that are freely released together with the library, are discussed in \S~\ref{subsec:tools}. Some conclusions are drawn in \S~\ref{sec:conclusions}, after which in the Appendix a complete description of all the instances of the library is provided.

%- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
%- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
%  End QPLIB-1.0.tex
%- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
%- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
